apiVersion: v1
kind: Namespace
metadata:
  name: security-monitoring
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: zeek-config
  namespace: security-monitoring
data:
  local.zeek: |
    ##! Local site policy. Customize as appropriate.
    ##!
    ##! This file will not be overwritten when upgrading or reinstalling!

    # This script logs which scripts were loaded during each run.
    @load misc/loaded-scripts

    # Apply the default tuning scripts for common tuning settings.
    @load tuning/defaults

    # Load the scan detection script.
    @load misc/scan

    # Log some information about web applications being used.
    @load misc/app-stats

    # Detect traceroute being run on the network.
    @load misc/detect-traceroute

    # Generate notices when vulnerable versions of software are discovered.
    @load frameworks/software/vulnerable

    # Detect software changing (e.g. attacker installing hacked SSHD).
    @load frameworks/software/version-changes

    # This adds signatures to detect cleartext forward and reverse shell sessions.
    @load-sigs frameworks/signatures/detect-shellshock

    # Load all of the scripts that detect software in various protocols.
    @load protocols/ftp/software
    @load protocols/smtp/software
    @load protocols/ssh/software
    @load protocols/http/software

    # Load all of the scripts that detect malware in various protocols.
    @load-sigs frameworks/signatures/detect-windows-shells

    # Uncomment the following line to enable detection of the heartbleed attack.
    @load policy/protocols/ssl/heartbleed

    # Uncomment the following line to enable logging of connection VLANs.
    @load policy/protocols/conn/vlan-logging

    # Uncomment the following line to enable logging of BPF filter expressions.
    @load policy/frameworks/packet-filter/log-packets

    # Enable JSON logging for easier integration
    @load policy/tuning/json-logs.zeek
    redef LogAscii::use_json = T;

    # Load custom DPI Framework scripts
    @load site/dpi-framework/load-scripts
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: zeek-custom-scripts
  namespace: security-monitoring
data:
  load-scripts.zeek: |
    ##! Main script to load all custom scripts

    # Load base protocols
    @load base/protocols/conn
    @load base/protocols/http
    @load base/protocols/dns
    @load base/protocols/ssl
    @load base/protocols/ssh
    @load base/protocols/smtp
    @load base/protocols/ftp

    # Load VLAN logging
    @load policy/protocols/conn/vlan-logging

    # Load custom scripts
    @load ./app-detection
    @load ./vlan-processing
    @load ./iot-detection
    @load ./port-detection
    @load ./protocol-detection
    @load ./encrypted-dns-detection
    @load ./iot-protocols

    # Print a message when scripts are loaded
    event zeek_init() {
        print "Loaded custom DPI Framework scripts";
    }

  app-detection.zeek: |
    ##! Script for enhanced application detection
    ##! This script adds additional application detection capabilities to Zeek

    @load base/protocols/conn
    @load base/protocols/http
    @load base/protocols/dns
    @load base/protocols/ssl
    @load base/protocols/ssh
    @load policy/protocols/conn/vlan-logging

    module AppDetection;

    export {
        # Define new application types
        const APP_NETFLIX = "netflix" &redef;
        const APP_YOUTUBE = "youtube" &redef;
        const APP_ZOOM = "zoom" &redef;
        const APP_PLEX = "plex" &redef;
        const APP_SPOTIFY = "spotify" &redef;
        const APP_HULU = "hulu" &redef;
        const APP_AMAZON = "amazon-video" &redef;
        const APP_DISNEY = "disney-plus" &redef;

        # Add to the connection record
        redef record Conn::Info += {
            app: string &optional &log;
            vlan: int &optional &log;
        };
    }

    # Netflix detection
    event http_header(c: connection, is_orig: bool, name: string, value: string) {
        if (name == "HOST" && /netflix\.com/ in value) {
            c$conn$app = APP_NETFLIX;
        }
    }

    # YouTube detection
    event http_header(c: connection, is_orig: bool, name: string, value: string) {
        if (name == "HOST" && /youtube\.com/ in value) {
            c$conn$app = APP_YOUTUBE;
        }
        else if (name == "HOST" && /youtu\.be/ in value) {
            c$conn$app = APP_YOUTUBE;
        }
    }

    # Zoom detection
    event ssl_established(c: connection) {
        if (c$ssl?$server_name && /zoom\.us/ in c$ssl$server_name) {
            c$conn$app = APP_ZOOM;
        }
    }

    # VLAN logging
    event connection_state_remove(c: connection) {
        if (c?$vlan) {
            c$conn$vlan = c$vlan;
        }
    }

  vlan-processing.zeek: |
    ##! Script for VLAN-specific processing
    ##! This script adds VLAN-aware processing to Zeek

    @load base/protocols/conn
    @load policy/protocols/conn/vlan-logging
    @load ./app-detection

    module VLANProcessing;

    export {
        # Define VLAN configurations
        type VLANConfig: record {
            id: count;
            name: string;
            subnet: subnet;
            default_policy: string;
            applications: set[string];
        };

        # Global table of VLAN configurations
        global vlan_configs: table[count] of VLANConfig;

        # Initialize VLAN configurations
        global initialize_vlan_configs: function();
    }

    # Initialize VLAN configurations
    function initialize_vlan_configs() {
        # IoT VLAN
        local iot_vlan: VLANConfig = [$id=10,
                                     $name="iot",
                                     $subnet=192.168.10.0/24,
                                     $default_policy="restrict",
                                     $applications=set("mqtt", "http", "dns")];
        vlan_configs[10] = iot_vlan;

        # Media VLAN
        local media_vlan: VLANConfig = [$id=20,
                                       $name="media",
                                       $subnet=192.168.20.0/24,
                                       $default_policy="allow",
                                       $applications=set("rtsp", "rtmp", "http", "https")];
        vlan_configs[20] = media_vlan;

        # Guest VLAN
        local guest_vlan: VLANConfig = [$id=30,
                                       $name="guest",
                                       $subnet=192.168.30.0/24,
                                       $default_policy="deny",
                                       $applications=set("http", "https", "dns")];
        vlan_configs[30] = guest_vlan;
    }

    # Check if an application is allowed on a VLAN
    function is_application_allowed(vlan_id: count, app: string): bool {
        if (vlan_id !in vlan_configs) {
            return T;  # If VLAN not configured, allow by default
        }

        local config = vlan_configs[vlan_id];

        # If no applications specified, allow all
        if (|config$applications| == 0) {
            return T;
        }

        # Check if application is in allowed list
        if (app in config$applications) {
            return T;
        }

        # Default policy
        if (config$default_policy == "allow") {
            return T;
        } else if (config$default_policy == "deny") {
            return F;
        } else {  # restrict
            return F;
        }
    }

    # Initialize VLAN configurations when Zeek starts
    event zeek_init() {
        initialize_vlan_configs();
    }

    # Process connections with VLAN information
    event connection_state_remove(c: connection) {
        if (!c?$vlan) {
            return;
        }

        local vlan_id = c$vlan;
        local app = "";

        # Get application if available
        if (c$conn?$app) {
            app = c$conn$app;
        } else if (c$conn?$service) {
            app = c$conn$service;
        }

        # Skip if no application identified
        if (app == "") {
            return;
        }

        # Check if application is allowed on this VLAN
        local allowed = is_application_allowed(vlan_id, app);

        # Log the result
        if (!allowed) {
            local msg = fmt("Application %s not allowed on VLAN %d", app, vlan_id);
            print msg;

            # In a real implementation, this would trigger an alert or block the traffic
        }
    }

  iot-detection.zeek: |
    ##! Script for IoT device detection
    ##! This script adds detection capabilities for IoT devices

    @load base/protocols/conn
    @load base/protocols/http
    @load base/protocols/dns
    @load base/protocols/ssl
    @load base/protocols/mqtt
    @load policy/protocols/conn/vlan-logging
    @load ./app-detection

    module IoTDetection;

    export {
        # Define IoT device types
        const DEV_AMAZON_ECHO = "amazon-echo" &redef;
        const DEV_GOOGLE_HOME = "google-home" &redef;
        const DEV_NEST = "nest" &redef;
        const DEV_RING = "ring" &redef;
        const DEV_PHILIPS_HUE = "philips-hue" &redef;
        const DEV_SONOS = "sonos" &redef;
        const DEV_ROKU = "roku" &redef;
        const DEV_APPLE_TV = "apple-tv" &redef;
        const DEV_CHROMECAST = "chromecast" &redef;
        const DEV_SMART_TV = "smart-tv" &redef;
        const DEV_SAMSUNG_TV = "samsung-tv" &redef;
        const DEV_LG_TV = "lg-tv" &redef;
        const DEV_VIZIO_TV = "vizio-tv" &redef;
        const DEV_SMART_PLUG = "smart-plug" &redef;
        const DEV_SMART_BULB = "smart-bulb" &redef;
        const DEV_SMART_LOCK = "smart-lock" &redef;
        const DEV_SMART_THERMOSTAT = "smart-thermostat" &redef;
        const DEV_SMART_DOORBELL = "smart-doorbell" &redef;
        const DEV_SMART_CAMERA = "smart-camera" &redef;
        const DEV_SMART_SPEAKER = "smart-speaker" &redef;
        const DEV_SMART_HOME = "smart-home" &redef;

        # Add to the connection record
        redef record Conn::Info += {
            iot_device: string &optional &log;
            iot_vendor: string &optional &log;
        };

        # IoT vendors
        const VENDOR_AMAZON = "amazon" &redef;
        const VENDOR_GOOGLE = "google" &redef;
        const VENDOR_APPLE = "apple" &redef;
        const VENDOR_SAMSUNG = "samsung" &redef;
        const VENDOR_LG = "lg" &redef;
        const VENDOR_PHILIPS = "philips" &redef;
        const VENDOR_SONOS = "sonos" &redef;
        const VENDOR_NEST = "nest" &redef;
        const VENDOR_RING = "ring" &redef;
        const VENDOR_ROKU = "roku" &redef;
        const VENDOR_TP_LINK = "tp-link" &redef;
        const VENDOR_BELKIN = "belkin" &redef;
        const VENDOR_WYZE = "wyze" &redef;
        const VENDOR_ARLO = "arlo" &redef;
    }

    # Helper function to set IoT device info
    function set_iot_info(c: connection, device: string, vendor: string) {
        c$conn$iot_device = device;
        c$conn$iot_vendor = vendor;
        c$conn$app_category = AppDetection::CAT_IOT;
    }

    # Amazon Echo / Alexa detection
    event http_header(c: connection, is_orig: bool, name: string, value: string) {
        if (name == "HOST") {
            if (/alexa\.amazon\.com/ in value) {
                set_iot_info(c, DEV_AMAZON_ECHO, VENDOR_AMAZON);
            }
        }
    }

    event ssl_established(c: connection) {
        if (c$ssl?$server_name) {
            if (/alexa\.amazon\.com/ in c$ssl$server_name) {
                set_iot_info(c, DEV_AMAZON_ECHO, VENDOR_AMAZON);
            }
        }
    }

  port-detection.zeek: |
    ##! Script for port-based application detection
    ##! This script adds detection capabilities based on port numbers

    @load base/protocols/conn
    @load ./app-detection

    module PortDetection;

    export {
        # Port to application mapping
        global port_app_map: table[port] of string = {
            # Web
            80/tcp  => "http",
            443/tcp => "https",
            8080/tcp => "http",
            8443/tcp => "https",

            # Email
            25/tcp  => "smtp",
            587/tcp => "smtp",
            465/tcp => "smtps",
            110/tcp => "pop3",
            995/tcp => "pop3s",
            143/tcp => "imap",
            993/tcp => "imaps",

            # File transfer
            21/tcp  => "ftp",
            22/tcp  => "ssh",

            # Remote access
            3389/tcp => "rdp",
            5900/tcp => "vnc",

            # Streaming
            1935/tcp => "rtmp",
            554/tcp  => "rtsp",

            # IoT
            1883/tcp => "mqtt",
            8883/tcp => "mqtts",
            5683/tcp => "coap"
        };
    }

    # Helper function to set application based on port
    function set_app_info_from_port(c: connection) {
        local dst_port = c$id$resp_p;
        local proto = get_port_transport_proto(dst_port);
        local port_num = port_to_count(dst_port);

        # Create the port with the correct protocol
        local p: port;
        if (proto == tcp) {
            p = port(port_num, tcp);
        } else if (proto == udp) {
            p = port(port_num, udp);
        } else {
            return;
        }

        # Check if we have an application mapping for this port
        if (p in port_app_map) {
            c$conn$service = port_app_map[p];
        }
    }

    # Apply port-based detection when a connection is established
    event connection_established(c: connection) {
        # Only apply if no service has been identified yet
        if (!c$conn?$service || c$conn$service == "") {
            set_app_info_from_port(c);
        }
    }

  protocol-detection.zeek: |
    ##! Script for protocol-specific application detection
    ##! This script adds detection capabilities based on protocol analysis

    @load base/protocols/conn
    @load base/protocols/http
    @load base/protocols/dns
    @load base/protocols/ssl
    @load ./app-detection

    module ProtocolDetection;

    export {
        # Protocol to application mapping
        global protocol_app_map: table[string] of string = {
            "http"  => "http",
            "https" => "https",
            "ssl"   => "https",
            "ssh"   => "ssh",
            "dns"   => "dns",
            "smtp"  => "smtp",
            "ftp"   => "ftp",
            "mqtt"  => "mqtt",
            "coap"  => "coap"
        };
    }

    # Helper function to set application based on protocol
    function set_app_info_from_protocol(c: connection, protocol: string) {
        # Check if we have an application mapping for this protocol
        if (protocol in protocol_app_map) {
            c$conn$service = protocol_app_map[protocol];
        }
    }

    # Apply protocol-based detection when a protocol is detected
    event protocol_confirmation(c: connection, atype: Analyzer::Tag, aid: count) {
        local protocol = Analyzer::name(atype);

        # Only apply if no service has been identified yet
        if (!c$conn?$service || c$conn$service == "") {
            set_app_info_from_protocol(c, protocol);
        }
    }

  encrypted-dns-detection.zeek: |
    ##! Script for encrypted DNS detection
    ##! This script adds detection capabilities for DNSCrypt, DoT, and DoH

    @load base/protocols/conn
    @load base/protocols/dns
    @load base/protocols/http
    @load base/protocols/ssl
    @load policy/protocols/conn/vlan-logging
    @load ./app-detection

    module EncryptedDNSDetection;

    export {
        # Define encrypted DNS types
        const DNS_DNSCRYPT = "dnscrypt" &redef;
        const DNS_DOT = "dns-over-tls" &redef;
        const DNS_DOH = "dns-over-https" &redef;

        # Add to the connection record
        redef record Conn::Info += {
            encrypted_dns: bool &default=F &log;
            encrypted_dns_type: string &optional &log;
        };

        # Known DoH providers
        global doh_providers: set[string] = {
            "dns.google",
            "cloudflare-dns.com",
            "dns.quad9.net",
            "dns.adguard.com"
        };

        # Known DoT providers
        global dot_providers: set[string] = {
            "dns.google",
            "cloudflare-dns.com",
            "dns.quad9.net",
            "dns.adguard.com"
        };

        # DNSCrypt port
        const DNSCRYPT_PORT = 443/udp &redef;

        # DoT port
        const DOT_PORT = 853/tcp &redef;
    }

    # Helper function to set encrypted DNS info
    function set_encrypted_dns_info(c: connection, dns_type: string) {
        c$conn$encrypted_dns = T;
        c$conn$encrypted_dns_type = dns_type;
        c$conn$service = dns_type;
        c$conn$app_category = "network-service";
    }

    # Detect DoH via HTTP headers
    event http_header(c: connection, is_orig: bool, name: string, value: string) {
        if (name == "HOST") {
            if (value in doh_providers) {
                set_encrypted_dns_info(c, DNS_DOH);
            }
        }
        else if (name == "ACCEPT") {
            if (value == "application/dns-message" || value == "application/dns-json") {
                set_encrypted_dns_info(c, DNS_DOH);
            }
        }
    }

    # Detect DoT via SSL/TLS
    event ssl_established(c: connection) {
        if (c$id$resp_p == DOT_PORT) {
            set_encrypted_dns_info(c, DNS_DOT);
        }
        else if (c$ssl?$server_name && c$ssl$server_name in dot_providers) {
            set_encrypted_dns_info(c, DNS_DOT);
        }
    }

    # Detect DNSCrypt via port
    event connection_established(c: connection) {
        if (c$id$resp_p == DNSCRYPT_PORT) {
            set_encrypted_dns_info(c, DNS_DNSCRYPT);
        }
    }

  iot-protocols.zeek: |
    ##! Script for IoT protocol detection
    ##! This script adds detection capabilities for IoT protocols

    @load base/protocols/conn
    @load base/protocols/http
    @load base/protocols/dns
    @load base/protocols/ssl
    @load base/protocols/mqtt
    @load policy/protocols/conn/vlan-logging
    @load ./app-detection
    @load ./iot-detection

    module IoTProtocols;

    export {
        # Define IoT protocol types
        const PROTO_MQTT = "mqtt" &redef;
        const PROTO_MQTT_SN = "mqtt-sn" &redef;
        const PROTO_COAP = "coap" &redef;
        const PROTO_AMQP = "amqp" &redef;
        const PROTO_ZIGBEE = "zigbee" &redef;
        const PROTO_ZWAVE = "zwave" &redef;
        const PROTO_THREAD = "thread" &redef;
        const PROTO_BACNET = "bacnet" &redef;
        const PROTO_MODBUS = "modbus" &redef;
        const PROTO_KNX = "knx" &redef;

        # Protocol ports
        const MQTT_PORTS: set[port] = {
            1883/tcp,  # MQTT
            8883/tcp   # MQTT over TLS
        };

        const MQTT_SN_PORTS: set[port] = {
            1883/udp  # MQTT-SN
        };

        const COAP_PORTS: set[port] = {
            5683/udp,  # CoAP
            5684/udp   # CoAP over DTLS
        };

        const AMQP_PORTS: set[port] = {
            5672/tcp,  # AMQP
            5671/tcp   # AMQP over TLS
        };

        const MODBUS_PORTS: set[port] = {
            502/tcp   # Modbus TCP
        };
    }

    # Helper function to set IoT protocol info
    function set_iot_protocol_info(c: connection, protocol: string) {
        c$conn$service = protocol;
        c$conn$app_category = AppDetection::CAT_IOT;
    }

    # Detect IoT protocols via port
    event connection_established(c: connection) {
        if (c$id$resp_p in MQTT_PORTS) {
            set_iot_protocol_info(c, PROTO_MQTT);
        }
        else if (c$id$resp_p in MQTT_SN_PORTS) {
            set_iot_protocol_info(c, PROTO_MQTT_SN);
        }
        else if (c$id$resp_p in COAP_PORTS) {
            set_iot_protocol_info(c, PROTO_COAP);
        }
        else if (c$id$resp_p in AMQP_PORTS) {
            set_iot_protocol_info(c, PROTO_AMQP);
        }
        else if (c$id$resp_p in MODBUS_PORTS) {
            set_iot_protocol_info(c, PROTO_MODBUS);
        }
    }

    # Detect MQTT via protocol analyzer
    event mqtt_connect(c: connection, msg: MQTT::ConnectMsg) {
        set_iot_protocol_info(c, PROTO_MQTT);

        # Check for specific IoT devices in client ID
        IoTDetection::set_iot_info_from_mqtt(c, msg$client_id);
    }
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: zeek-logs-pvc
  namespace: security-monitoring
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: zeek
  namespace: security-monitoring
  labels:
    app: zeek
spec:
  replicas: 1
  selector:
    matchLabels:
      app: zeek
  template:
    metadata:
      labels:
        app: zeek
    spec:
      # Use host network to capture traffic
      hostNetwork: true
      containers:
      - name: zeek
        image: zeek/zeek:latest
        securityContext:
          capabilities:
            add: ["NET_RAW", "NET_ADMIN"]
          privileged: true
        command:
        - "/bin/bash"
        - "-c"
        - |
          mkdir -p /opt/zeek/share/zeek/site/local
          cp /zeek-config/local.zeek /opt/zeek/share/zeek/site/local/local.zeek
          /opt/zeek/bin/zeekctl deploy
          tail -f /opt/zeek/logs/current/stderr.log
        volumeMounts:
        - name: zeek-logs
          mountPath: /opt/zeek/logs
        - name: zeek-config
          mountPath: /zeek-config
        - name: zeek-custom-scripts
          mountPath: /opt/zeek/share/zeek/site/dpi-framework
        env:
        - name: INTERFACE
          value: "eth0" # Change to the appropriate interface
        resources:
          limits:
            cpu: "2"
            memory: "4Gi"
          requests:
            cpu: "1"
            memory: "2Gi"
        livenessProbe:
          exec:
            command:
            - sh
            - -c
            - "pgrep zeek || pgrep zeekctl"
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          exec:
            command:
            - sh
            - -c
            - "test -f /opt/zeek/logs/current/conn.log"
          initialDelaySeconds: 30
          periodSeconds: 10
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: false  # Zeek needs root for packet capture
          runAsUser: 0
          capabilities:
            add: ["NET_RAW", "NET_ADMIN", "SYS_NICE"]
            drop: ["ALL"]
      volumes:
      - name: zeek-logs
        persistentVolumeClaim:
          claimName: zeek-logs-pvc
      - name: zeek-config
        configMap:
          name: zeek-config
      - name: zeek-custom-scripts
        configMap:
          name: zeek-custom-scripts
---
apiVersion: v1
kind: Service
metadata:
  name: zeek
  namespace: security-monitoring
spec:
  selector:
    app: zeek
  ports:
  - port: 9999
    targetPort: 9999
    name: zeek-api
  type: ClusterIP
