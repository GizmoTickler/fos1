name: Development Tools

on:
  workflow_dispatch:
    inputs:
      operation:
        description: 'Development operation to perform'
        required: true
        default: 'generate-manifests'
        type: choice
        options:
          - generate-manifests
          - create-service-config
          - validate-architecture
          - generate-docs
          - scaffold-package
      service:
        description: 'Target service (if applicable)'
        required: false
        type: string
      resource_type:
        description: 'Resource type (for scaffolding)'
        required: false
        type: choice
        options:
          - deployment
          - daemonset
          - configmap
          - service
          - crd
      package_name:
        description: 'Package name (for scaffolding Go code)'
        required: false
        type: string

jobs:
  generate-manifests:
    if: ${{ github.event.inputs.operation == 'generate-manifests' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up kustomize
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/

      - name: Generate Kubernetes manifests
        run: |
          mkdir -p dist/manifests
          
          if [ -d "manifests/base" ]; then
            kustomize build manifests/base > dist/manifests/all.yaml
            echo "Generated manifests:"
            echo "---"
            cat dist/manifests/all.yaml
          else
            echo "No manifests found. Creating placeholder directories."
            mkdir -p manifests/{base,overlays}
            echo "# Placeholder kustomization" > manifests/base/kustomization.yaml
          fi

      - name: Upload manifests artifact
        uses: actions/upload-artifact@v3
        with:
          name: kubernetes-manifests
          path: dist/manifests

  create-service-config:
    if: ${{ github.event.inputs.operation == 'create-service-config' && github.event.inputs.service != '' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up kustomize
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/

      - name: Create service configuration
        env:
          SERVICE_NAME: ${{ github.event.inputs.service }}
        run: |
          SERVICE_DIR="manifests/base/${SERVICE_NAME}"
          mkdir -p "${SERVICE_DIR}"
          
          # Create deployment template
          cat > "${SERVICE_DIR}/deployment.yaml" << EOL
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${SERVICE_NAME}
          spec:
            selector:
              matchLabels:
                app: ${SERVICE_NAME}
            template:
              metadata:
                labels:
                  app: ${SERVICE_NAME}
              spec:
                containers:
                - name: ${SERVICE_NAME}
                  image: ${SERVICE_NAME}:latest
                  resources:
                    limits:
                      memory: "128Mi"
                      cpu: "500m"
          EOL
          
          # Create service template
          cat > "${SERVICE_DIR}/service.yaml" << EOL
          apiVersion: v1
          kind: Service
          metadata:
            name: ${SERVICE_NAME}
          spec:
            selector:
              app: ${SERVICE_NAME}
            ports:
            - port: 80
              targetPort: 8080
          EOL
          
          # Create configmap template
          cat > "${SERVICE_DIR}/configmap.yaml" << EOL
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: ${SERVICE_NAME}-config
          data:
            config.yaml: |
              # ${SERVICE_NAME} configuration
              log_level: info
              feature_flags:
                enabled: true
          EOL
          
          # Create kustomization file
          cat > "${SERVICE_DIR}/kustomization.yaml" << EOL
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization
          resources:
          - deployment.yaml
          - service.yaml
          - configmap.yaml
          EOL
          
          echo "Created configuration for ${SERVICE_NAME} in ${SERVICE_DIR}"
          ls -la "${SERVICE_DIR}"

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add manifests/
          git commit -m "Add configuration for ${{ github.event.inputs.service }}"
          git push

  validate-architecture:
    if: ${{ github.event.inputs.operation == 'validate-architecture' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y graphviz

      - name: Generate architecture diagram
        run: |
          # Create simple dependency graph
          mkdir -p dist/architecture
          
          # Create DOT file for Graphviz
          cat > dist/architecture/dependencies.dot << EOL
          digraph G {
            rankdir=TB;
            node [shape=box, style=filled, fillcolor=lightblue];
            
            // Network layer
            "Physical Interfaces" -> "Kernel Networking";
            "Kernel Networking" -> "eBPF/XDP";
            "eBPF/XDP" -> "Kubernetes CNI";
            
            // Core services
            "Kubernetes CNI" -> "CoreDNS";
            "Kubernetes CNI" -> "Kea DHCP";
            "Kubernetes CNI" -> "NTP (Chrony)";
            "Kubernetes CNI" -> "mDNS (Avahi)";
            
            // Security services
            "Kubernetes CNI" -> "Suricata";
            "Kubernetes CNI" -> "Zeek";
            "Kubernetes CNI" -> "Firewall";
            
            // Service dependencies
            "Kea DHCP" -> "CoreDNS" [style=dashed, label="updates"];
            "CoreDNS" -> "AdGuard Home" [style=dashed];
            
            // Monitoring
            "Suricata" -> "Elasticsearch";
            "Zeek" -> "Elasticsearch";
            "Elasticsearch" -> "Kibana";
            
            // Subgraph for layers
            subgraph cluster_0 {
              label = "Infrastructure Layer";
              color = lightgrey;
              "Physical Interfaces"; "Kernel Networking"; "eBPF/XDP"; "Kubernetes CNI";
            }
            
            subgraph cluster_1 {
              label = "Network Services Layer";
              color = lightgrey;
              "CoreDNS"; "Kea DHCP"; "NTP (Chrony)"; "mDNS (Avahi)"; "AdGuard Home";
            }
            
            subgraph cluster_2 {
              label = "Security Layer";
              color = lightgrey;
              "Suricata"; "Zeek"; "Firewall";
            }
            
            subgraph cluster_3 {
              label = "Observability Layer";
              color = lightgrey;
              "Elasticsearch"; "Kibana";
            }
          }
          EOL
          
          # Generate PNG from DOT file
          dot -Tpng dist/architecture/dependencies.dot -o dist/architecture/dependencies.png
          
          echo "Architecture diagram generated"

      - name: Validate component presence
        run: |
          echo "Validating required components in the architecture..."
          
          # Check for required manifests directories
          MISSING_COMPONENTS=""
          
          REQUIRED_COMPONENTS=("network" "security" "dns" "dhcp" "monitoring")
          for component in "${REQUIRED_COMPONENTS[@]}"; do
            if [ ! -d "manifests/${component}" ]; then
              MISSING_COMPONENTS="${MISSING_COMPONENTS}\n- ${component}"
            fi
          done
          
          if [ ! -z "${MISSING_COMPONENTS}" ]; then
            echo -e "Missing component directories:${MISSING_COMPONENTS}"
            echo "Please consider adding these components to complete the architecture."
          else
            echo "All required component directories are present."
          fi

      - name: Upload architecture artifacts
        uses: actions/upload-artifact@v3
        with:
          name: architecture-diagram
          path: dist/architecture

  generate-docs:
    if: ${{ github.event.inputs.operation == 'generate-docs' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Generate service inventory
        run: |
          mkdir -p dist/docs
          
          # Create service inventory markdown
          cat > dist/docs/service-inventory.md << EOL
          # Service Inventory
          
          This document provides an inventory of services in the Kubernetes-based router/firewall.
          
          ## Core Services
          
          | Service | Purpose | Technology | Configuration |
          |---------|---------|------------|---------------|
          | DNS | Name resolution | CoreDNS, AdGuard Home | manifests/dns/ |
          | DHCP | Address assignment | Kea DHCP | manifests/dhcp/ |
          | Router Advertisements | IPv6 configuration | RADVD | manifests/dhcp/ |
          | NTP | Time synchronization | Chrony | manifests/core/ |
          | mDNS | Service discovery | Avahi | manifests/dns/ |
          
          ## Security Services
          
          | Service | Purpose | Technology | Configuration |
          |---------|---------|------------|---------------|
          | Firewall | Packet filtering | eBPF, NFTables | manifests/security/ |
          | IDS/IPS | Threat detection | Suricata | manifests/security/ |
          | Network Monitoring | Protocol analysis | Zeek | manifests/security/ |
          | DPI | Traffic inspection | nProbe | manifests/security/ |
          | VPN | Secure remote access | WireGuard, OpenVPN | manifests/vpn/ |
          
          ## Observability Services
          
          | Service | Purpose | Technology | Configuration |
          |---------|---------|------------|---------------|
          | Logging | Log aggregation | Fluentd | manifests/monitoring/ |
          | Storage | Log storage | Elasticsearch | manifests/monitoring/ |
          | Visualization | Log visualization | Kibana | manifests/monitoring/ |
          | Metrics | Performance data | Prometheus | manifests/monitoring/ |
          | Dashboards | Metric visualization | Grafana | manifests/monitoring/ |
          
          EOL
          
          echo "Service inventory document generated"

      - name: Create configuration reference
        run: |
          # Create configuration reference
          cat > dist/docs/configuration-reference.md << EOL
          # Configuration Reference
          
          This document provides reference information for configuring the router/firewall services.
          
          ## Network Configuration
          
          Network interfaces and routing are configured through Talos Machine Configuration:
          
          \`\`\`yaml
          machine:
            network:
              interfaces:
                - interface: eth0
                  dhcp: true
                - interface: eth1
                  addresses:
                    - 192.168.1.1/24
                  vip:
                    ip: 192.168.1.254
          \`\`\`
          
          ## Service Configuration
          
          Services are configured through Kubernetes Custom Resources:
          
          \`\`\`yaml
          apiVersion: networking.fos1.io/v1
          kind: DHCPConfig
          metadata:
            name: main-network
          spec:
            subnet: 192.168.1.0/24
            range:
              start: 192.168.1.100
              end: 192.168.1.200
            options:
              routers: 192.168.1.1
              domain-name-servers: 192.168.1.1
          \`\`\`
          
          ## DNS Configuration
          
          DNS services use CoreDNS with custom configuration:
          
          \`\`\`
          .:53 {
            forward . 8.8.8.8 8.8.4.4
            cache 30
            errors
            log
          }
          
          local:53 {
            file /etc/coredns/db.local
            cache 30
            errors
            log
          }
          \`\`\`
          
          ## Firewall Configuration
          
          Firewall rules use Kubernetes NetworkPolicy and custom resources:
          
          \`\`\`yaml
          apiVersion: networking.fos1.io/v1
          kind: FirewallRule
          metadata:
            name: allow-web
          spec:
            source: any
            destination: internal
            ports: [80, 443]
            action: accept
          \`\`\`
          
          EOL
          
          echo "Configuration reference document generated"

      - name: Upload documentation artifacts
        uses: actions/upload-artifact@v3
        with:
          name: generated-docs
          path: dist/docs

  scaffold-package:
    if: ${{ github.event.inputs.operation == 'scaffold-package' && github.event.inputs.package_name != '' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.20'

      - name: Scaffold Go package
        env:
          PACKAGE_NAME: ${{ github.event.inputs.package_name }}
        run: |
          PACKAGE_DIR="pkg/${PACKAGE_NAME}"
          mkdir -p "${PACKAGE_DIR}"
          
          # Create main package file
          cat > "${PACKAGE_DIR}/${PACKAGE_NAME}.go" << EOL
          // Package ${PACKAGE_NAME} provides functionality for the router/firewall system.
          package ${PACKAGE_NAME}
          
          import (
              "context"
              "errors"
              "log"
          )
          
          // Config defines the configuration for ${PACKAGE_NAME}.
          type Config struct {
              // Add configuration fields here
              Enabled bool
              LogLevel string
          }
          
          // Service provides the main functionality for ${PACKAGE_NAME}.
          type Service struct {
              config Config
              // Add service fields here
          }
          
          // NewService creates a new instance of the ${PACKAGE_NAME} service.
          func NewService(config Config) (*Service, error) {
              if config.LogLevel == "" {
                  config.LogLevel = "info"
              }
              
              return &Service{
                  config: config,
              }, nil
          }
          
          // Start initializes and starts the ${PACKAGE_NAME} service.
          func (s *Service) Start(ctx context.Context) error {
              log.Printf("Starting ${PACKAGE_NAME} service with log level: %s", s.config.LogLevel)
              
              // Implement service startup logic here
              
              return nil
          }
          
          // Stop gracefully shuts down the ${PACKAGE_NAME} service.
          func (s *Service) Stop(ctx context.Context) error {
              log.Printf("Stopping ${PACKAGE_NAME} service")
              
              // Implement service shutdown logic here
              
              return nil
          }
          EOL
          
          # Create test file
          cat > "${PACKAGE_DIR}/${PACKAGE_NAME}_test.go" << EOL
          package ${PACKAGE_NAME}
          
          import (
              "context"
              "testing"
          )
          
          func TestNewService(t *testing.T) {
              config := Config{
                  Enabled: true,
                  LogLevel: "debug",
              }
              
              service, err := NewService(config)
              if err != nil {
                  t.Fatalf("Failed to create service: %v", err)
              }
              
              if service == nil {
                  t.Fatal("Expected service to be created, got nil")
              }
              
              if service.config.LogLevel != "debug" {
                  t.Errorf("Expected log level 'debug', got '%s'", service.config.LogLevel)
              }
          }
          
          func TestServiceLifecycle(t *testing.T) {
              config := Config{
                  Enabled: true,
              }
              
              service, err := NewService(config)
              if err != nil {
                  t.Fatalf("Failed to create service: %v", err)
              }
              
              ctx := context.Background()
              
              err = service.Start(ctx)
              if err != nil {
                  t.Fatalf("Failed to start service: %v", err)
              }
              
              err = service.Stop(ctx)
              if err != nil {
                  t.Fatalf("Failed to stop service: %v", err)
              }
          }
          EOL
          
          # Create readme
          cat > "${PACKAGE_DIR}/README.md" << EOL
          # ${PACKAGE_NAME} Package
          
          This package provides functionality for the router/firewall system.
          
          ## Usage
          
          \`\`\`go
          import (
              "${PACKAGE_NAME}"
          )
          
          func main() {
              config := ${PACKAGE_NAME}.Config{
                  Enabled: true,
                  LogLevel: "info",
              }
              
              service, err := ${PACKAGE_NAME}.NewService(config)
              if err != nil {
                  log.Fatalf("Failed to create service: %v", err)
              }
              
              ctx := context.Background()
              if err := service.Start(ctx); err != nil {
                  log.Fatalf("Failed to start service: %v", err)
              }
              
              // Use service...
              
              if err := service.Stop(ctx); err != nil {
                  log.Fatalf("Failed to stop service: %v", err)
              }
          }
          \`\`\`
          EOL
          
          echo "Go package scaffolded in ${PACKAGE_DIR}"

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add pkg/
          git commit -m "Scaffold package: ${{ github.event.inputs.package_name }}"
          git push